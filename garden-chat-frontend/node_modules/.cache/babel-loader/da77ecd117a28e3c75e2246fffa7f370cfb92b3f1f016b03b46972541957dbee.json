{"ast":null,"code":"// src/services/WebSocketService.js\nimport { Stomp } from '@stomp/stompjs'; // Import Stomp client library\nimport SockJS from 'sockjs-client'; // Import SockJS for WebSocket fallback support\n\n// Define the WebSocket endpoint URL (adjustable based on backend server location)\n// const URL = 'http://localhost:8088/ws';\n\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null;\n    this.typingCallback = null;\n    this.isConnected = false;\n    this.reconnectDelay = 5000; // Customizable reconnect delay\n  }\n  async connect(onMessageReceived, onUsersUpdated) {\n    if (this.isConnected) {\n      console.log(\"Already connected to WebSocket.\");\n      return;\n    }\n    try {\n      const socketFactory = () => new SockJS('http://localhost:8088/ws');\n      this.stompClient = Stomp.over(socketFactory);\n\n      // Configure heartbeats\n      this.stompClient.heartbeatIncoming = 10000; // Expect a heartbeat from the server every 10 seconds\n      this.stompClient.heartbeatOutgoing = 10000; // Send a heartbeat to the server every 10 seconds\n\n      // Add debug logging for lifecycle events\n      this.stompClient.debug = str => console.log(`[STOMP Debug] ${str}`);\n\n      // Add error handling for STOMP errors\n      this.stompClient.onStompError = frame => {\n        console.error('[STOMP Error] Broker reported error: ' + frame.headers['message']);\n        console.error('[STOMP Error] Additional details: ' + frame.body);\n      };\n      await new Promise((resolve, reject) => {\n        this.stompClient.connect({}, frame => {\n          console.log('[STOMP Connected] Frame received:', frame);\n\n          // Mark the client as connected\n          this.isConnected = true;\n\n          // Ensure subscriptions are set up after successful connection\n          // Delay subscription setup\n          setTimeout(() => {\n            console.log('[STOMP Info] Setting up subscriptions after successful connection...');\n            this._setupSubscriptions(onMessageReceived, onUsersUpdated);\n          }, 100); // Delay by 100ms\n\n          resolve(frame);\n        }, error => {\n          console.error('[STOMP Error] Connection error:', error);\n          reject(error);\n        });\n      });\n\n      // Set reconnect delay (if required for auto-reconnect)\n      this.stompClient.reconnectDelay = this.reconnectDelay || 5000;\n    } catch (error) {\n      console.error('[STOMP Error] Connection failed, retrying in ' + (this.reconnectDelay || 5000) + 'ms.');\n      setTimeout(() => this.connect(onMessageReceived, onUsersUpdated), this.reconnectDelay || 5000);\n    }\n  }\n\n  // Set up actions to be taken once the connection is successful\n  _setupSubscriptions(onMessageReceived, onUsersUpdated) {\n    if (this.stompClient && this.stompClient.connected) {\n      console.log('[STOMP Info] Setting up subscriptions...');\n\n      // Subscribe to the messages topic\n      this.stompClient.subscribe('/topic/messages', message => {\n        onMessageReceived(JSON.parse(message.body));\n        console.log('[STOMP Debug] Message received on /topic/messages:', message);\n      });\n\n      // Subscribe to the online-users topic\n      this.stompClient.subscribe('/topic/online-users', users => {\n        if (onUsersUpdated) {\n          onUsersUpdated(JSON.parse(users.body));\n        }\n        console.log('[STOMP Debug] Online users updated:', users);\n      });\n\n      // Subscribe to typing topic\n      this.stompClient.subscribe('/topic/typing', typingStatus => {\n        if (this.typingCallback) {\n          const {\n            username\n          } = JSON.parse(typingStatus.body);\n          this.typingCallback(username);\n        }\n        console.log('[STOMP Debug] Typing status received:', typingStatus);\n      });\n      console.log('[STOMP Info] Subscriptions successfully set up.');\n    } else {\n      console.error('[STOMP Warning] STOMP client is not connected. Retrying subscription setup...');\n      setTimeout(() => this._setupSubscriptions(onMessageReceived, onUsersUpdated), 1000);\n    }\n  }\n\n  // Set up the callback function for typing notifications\n  onTyping(callback) {\n    this.typingCallback = callback; // Assign the provided callback to typingCallback\n  }\n\n  // Send typing status to the server for a specific group\n  sendTypingStatus(username, group) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/typing',\n        body: JSON.stringify({\n          username,\n          group\n        })\n      });\n    }\n  }\n\n  // Send a chat message to the server\n  sendMessage(message) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/chat',\n        body: JSON.stringify(message)\n      });\n    }\n  }\n\n  // Notify server of user's presence (to mark as online)\n  sendUserPresence(username) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/online',\n        body: JSON.stringify({\n          username\n        })\n      });\n    }\n  }\n\n  // Disconnect the WebSocket client\n  disconnect() {\n    if (this.stompClient) {\n      this.stompClient.deactivate(); // Properly close the connection\n      this.isConnected = false; // Reset connection state\n    }\n  }\n}\n\n// Export a singleton instance of WebSocketService to be used across the app\nexport default new WebSocketService();","map":{"version":3,"names":["Stomp","SockJS","WebSocketService","constructor","stompClient","typingCallback","isConnected","reconnectDelay","connect","onMessageReceived","onUsersUpdated","console","log","socketFactory","over","heartbeatIncoming","heartbeatOutgoing","debug","str","onStompError","frame","error","headers","body","Promise","resolve","reject","setTimeout","_setupSubscriptions","connected","subscribe","message","JSON","parse","users","typingStatus","username","onTyping","callback","sendTypingStatus","group","publish","destination","stringify","sendMessage","sendUserPresence","disconnect","deactivate"],"sources":["D:/bootcamp/SpringFrame/Project/Garden-Chat-FullStack/garden-chat-frontend/src/services/WebSocketService.js"],"sourcesContent":["// src/services/WebSocketService.js\r\nimport { Stomp } from '@stomp/stompjs';    // Import Stomp client library\r\nimport SockJS from 'sockjs-client';        // Import SockJS for WebSocket fallback support\r\n\r\n// Define the WebSocket endpoint URL (adjustable based on backend server location)\r\n// const URL = 'http://localhost:8088/ws';\r\n\r\nclass WebSocketService {\r\n    constructor() {\r\n        this.stompClient = null;\r\n        this.typingCallback = null;\r\n        this.isConnected = false;\r\n        this.reconnectDelay = 5000;  // Customizable reconnect delay\r\n    }\r\n\r\n    async connect(onMessageReceived, onUsersUpdated) {\r\n        if (this.isConnected) {\r\n            console.log(\"Already connected to WebSocket.\");\r\n            return;\r\n        }\r\n    \r\n        try {\r\n            const socketFactory = () => new SockJS('http://localhost:8088/ws');\r\n            this.stompClient = Stomp.over(socketFactory);\r\n    \r\n            // Configure heartbeats\r\n            this.stompClient.heartbeatIncoming = 10000; // Expect a heartbeat from the server every 10 seconds\r\n            this.stompClient.heartbeatOutgoing = 10000; // Send a heartbeat to the server every 10 seconds\r\n    \r\n            // Add debug logging for lifecycle events\r\n            this.stompClient.debug = (str) => console.log(`[STOMP Debug] ${str}`);\r\n            \r\n            // Add error handling for STOMP errors\r\n            this.stompClient.onStompError = (frame) => {\r\n                console.error('[STOMP Error] Broker reported error: ' + frame.headers['message']);\r\n                console.error('[STOMP Error] Additional details: ' + frame.body);\r\n            };\r\n    \r\n            await new Promise((resolve, reject) => {\r\n                this.stompClient.connect({}, (frame) => {\r\n                    console.log('[STOMP Connected] Frame received:', frame);\r\n    \r\n                    // Mark the client as connected\r\n                    this.isConnected = true;\r\n    \r\n                    // Ensure subscriptions are set up after successful connection\r\n                     // Delay subscription setup\r\n    setTimeout(() => {\r\n        console.log('[STOMP Info] Setting up subscriptions after successful connection...');\r\n        this._setupSubscriptions(onMessageReceived, onUsersUpdated);\r\n    }, 100); // Delay by 100ms\r\n    \r\n                    resolve(frame);\r\n                }, (error) => {\r\n                    console.error('[STOMP Error] Connection error:', error);\r\n                    reject(error);\r\n                });\r\n            });\r\n    \r\n            // Set reconnect delay (if required for auto-reconnect)\r\n            this.stompClient.reconnectDelay = this.reconnectDelay || 5000;\r\n    \r\n        } catch (error) {\r\n            console.error('[STOMP Error] Connection failed, retrying in ' + (this.reconnectDelay || 5000) + 'ms.');\r\n            setTimeout(() => this.connect(onMessageReceived, onUsersUpdated), this.reconnectDelay || 5000);\r\n        }\r\n    }\r\n\r\n    // Set up actions to be taken once the connection is successful\r\n    _setupSubscriptions(onMessageReceived, onUsersUpdated) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            console.log('[STOMP Info] Setting up subscriptions...');\r\n    \r\n            // Subscribe to the messages topic\r\n            this.stompClient.subscribe('/topic/messages', (message) => {\r\n                onMessageReceived(JSON.parse(message.body));\r\n                console.log('[STOMP Debug] Message received on /topic/messages:', message);\r\n            });\r\n    \r\n            // Subscribe to the online-users topic\r\n            this.stompClient.subscribe('/topic/online-users', (users) => {\r\n                if (onUsersUpdated) {\r\n                    onUsersUpdated(JSON.parse(users.body));\r\n                }\r\n                console.log('[STOMP Debug] Online users updated:', users);\r\n            });\r\n    \r\n            // Subscribe to typing topic\r\n            this.stompClient.subscribe('/topic/typing', (typingStatus) => {\r\n                if (this.typingCallback) {\r\n                    const { username } = JSON.parse(typingStatus.body);\r\n                    this.typingCallback(username);\r\n                }\r\n                console.log('[STOMP Debug] Typing status received:', typingStatus);\r\n            });\r\n    \r\n            console.log('[STOMP Info] Subscriptions successfully set up.');\r\n        } else {\r\n            console.error('[STOMP Warning] STOMP client is not connected. Retrying subscription setup...');\r\n            setTimeout(() => this._setupSubscriptions(onMessageReceived, onUsersUpdated), 1000);\r\n        }\r\n    }\r\n\r\n    // Set up the callback function for typing notifications\r\n    onTyping(callback) {\r\n        this.typingCallback = callback; // Assign the provided callback to typingCallback\r\n    }\r\n\r\n    // Send typing status to the server for a specific group\r\n    sendTypingStatus(username, group) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/typing',\r\n                body: JSON.stringify({ username, group })\r\n            });\r\n        }\r\n    }\r\n\r\n    // Send a chat message to the server\r\n    sendMessage(message) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/chat',\r\n                body: JSON.stringify(message)\r\n            });\r\n        }\r\n    }\r\n\r\n    // Notify server of user's presence (to mark as online)\r\n    sendUserPresence(username) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/online',\r\n                body: JSON.stringify({ username })\r\n            });\r\n        }\r\n    }\r\n\r\n    // Disconnect the WebSocket client\r\n    disconnect() {\r\n        if (this.stompClient) {\r\n            this.stompClient.deactivate(); // Properly close the connection\r\n            this.isConnected = false;  // Reset connection state\r\n        }\r\n    }\r\n}\r\n\r\n// Export a singleton instance of WebSocketService to be used across the app\r\nexport default new WebSocketService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
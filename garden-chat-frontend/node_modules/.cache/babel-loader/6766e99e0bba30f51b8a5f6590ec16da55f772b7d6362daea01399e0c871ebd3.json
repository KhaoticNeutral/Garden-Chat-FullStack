{"ast":null,"code":"// src/services/WebSocketService.js\nimport { Stomp } from '@stomp/stompjs'; // Import Stomp client library\nimport SockJS from 'sockjs-client'; // Import SockJS for WebSocket fallback support\n\n// Define the WebSocket endpoint URL (adjustable based on backend server location)\n// const URL = 'http://localhost:8088/ws';\n\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null; // Initialize the STOMP client to null\n    this.typingCallback = null; // Initialize callback for typing notifications to null\n    this.isConnected = false; // Track the connection state to prevent multiple connections\n  }\n\n  // Connect to WebSocket and set up subscription channels\n  connect(onMessageReceived, onUsersUpdated) {\n    // If already connected, skip the connection attempt\n    if (this.isConnected) {\n      console.log(\"Already connected to WebSocket.\");\n      return;\n    }\n\n    // Create a SockJS instance using the WebSocket URL\n    const socketFactory = () => new SockJS('http://localhost:8088/ws');\n\n    // Create a STOMP client using the SockJS instance for WebSocket communication\n    this.stompClient = Stomp.over(socketFactory);\n\n    // Attempt to connect to the server\n    this.stompClient.connect({}, function (frame) {\n      console.log('Connected: ' + frame);\n\n      // Ensure subscriptions happen only after a successful connection\n      this.stompClient.subscribe('/topic/messages', function (message) {\n        onMessageReceived(JSON.parse(message.body));\n      });\n      this.stompClient.subscribe('/topic/online-users', function (users) {\n        if (onUsersUpdated) {\n          onUsersUpdated(JSON.parse(users.body));\n        }\n      });\n      this.stompClient.subscribe('/topic/typing', function (typingStatus) {\n        if (this.typingCallback) {\n          const {\n            username\n          } = JSON.parse(typingStatus.body);\n          this.typingCallback(username);\n        }\n      });\n    }, function (error) {\n      console.error(\"STOMP connection error: \", error);\n    });\n\n    // Set automatic reconnection delay to 5 seconds in case of disconnection\n    this.stompClient.reconnectDelay = 5000;\n    this.stompClient.debug = function (str) {\n      console.log(str); // This will log WebSocket connection events\n    };\n\n    // Handle STOMP errors reported by the message broker\n    this.stompClient.onStompError = frame => {\n      console.error('Broker reported error: ' + frame.headers['message']);\n      console.error('Additional details: ' + frame.body);\n    };\n  }\n\n  // Set up actions to be taken once the connection is successful\n  _setupSubscriptions(onMessageReceived, onUsersUpdated) {\n    // Subscribe to messages topic to receive chat messages\n    this.stompClient.subscribe('/topic/messages', message => {\n      onMessageReceived(JSON.parse(message.body)); // Invoke the provided callback with the parsed message\n    });\n\n    // Subscribe to the online-users topic to get updates on online users\n    this.stompClient.subscribe('/topic/online-users', users => {\n      if (onUsersUpdated) {\n        onUsersUpdated(JSON.parse(users.body)); // Invoke the provided callback with the updated user list\n      }\n    });\n\n    // Subscribe to typing topic to receive typing notifications\n    this.stompClient.subscribe('/topic/typing', typingStatus => {\n      if (this.typingCallback) {\n        const {\n          username\n        } = JSON.parse(typingStatus.body); // Parse typing status\n        this.typingCallback(username); // Invoke typing callback with username\n      }\n    });\n  }\n\n  // Set up the callback function for typing notifications\n  onTyping(callback) {\n    this.typingCallback = callback; // Assign the provided callback to typingCallback\n  }\n\n  // Send typing status to the server for a specific group\n  sendTypingStatus(username, group) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/typing',\n        body: JSON.stringify({\n          username,\n          group\n        })\n      });\n    }\n  }\n\n  // Send a chat message to the server\n  sendMessage(message) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/chat',\n        body: JSON.stringify(message)\n      });\n    }\n  }\n\n  // Notify server of user's presence (to mark as online)\n  sendUserPresence(username) {\n    if (this.stompClient && this.stompClient.connected) {\n      this.stompClient.publish({\n        destination: '/app/online',\n        body: JSON.stringify({\n          username\n        })\n      });\n    }\n  }\n\n  // Disconnect the WebSocket client\n  disconnect() {\n    if (this.stompClient) {\n      this.stompClient.deactivate(); // Properly close the connection\n      this.isConnected = false; // Reset connection state\n    }\n  }\n}\n\n// Export a singleton instance of WebSocketService to be used across the app\nconst webSocketService = new WebSocketService();\nexport default webSocketService;","map":{"version":3,"names":["Stomp","SockJS","WebSocketService","constructor","stompClient","typingCallback","isConnected","connect","onMessageReceived","onUsersUpdated","console","log","socketFactory","over","frame","subscribe","message","JSON","parse","body","users","typingStatus","username","error","reconnectDelay","debug","str","onStompError","headers","_setupSubscriptions","onTyping","callback","sendTypingStatus","group","connected","publish","destination","stringify","sendMessage","sendUserPresence","disconnect","deactivate","webSocketService"],"sources":["D:/bootcamp/SpringFrame/Project/Garden-Chat-FullStack/garden-chat-frontend/src/services/WebSocketService.js"],"sourcesContent":["// src/services/WebSocketService.js\r\nimport { Stomp } from '@stomp/stompjs';    // Import Stomp client library\r\nimport SockJS from 'sockjs-client';        // Import SockJS for WebSocket fallback support\r\n\r\n// Define the WebSocket endpoint URL (adjustable based on backend server location)\r\n// const URL = 'http://localhost:8088/ws';\r\n\r\nclass WebSocketService {\r\n    constructor() {\r\n        this.stompClient = null;      // Initialize the STOMP client to null\r\n        this.typingCallback = null;    // Initialize callback for typing notifications to null\r\n        this.isConnected = false;      // Track the connection state to prevent multiple connections\r\n    }\r\n\r\n    // Connect to WebSocket and set up subscription channels\r\n    connect(onMessageReceived, onUsersUpdated) {\r\n        // If already connected, skip the connection attempt\r\n        if (this.isConnected) {\r\n            console.log(\"Already connected to WebSocket.\");\r\n            return;\r\n        }\r\n\r\n        // Create a SockJS instance using the WebSocket URL\r\n        const socketFactory = () => new SockJS('http://localhost:8088/ws');\r\n\r\n        // Create a STOMP client using the SockJS instance for WebSocket communication\r\n        this.stompClient = Stomp.over(socketFactory);\r\n\r\n        // Attempt to connect to the server\r\n        this.stompClient.connect({}, function(frame) {\r\n            console.log('Connected: ' + frame);\r\n            \r\n            // Ensure subscriptions happen only after a successful connection\r\n            this.stompClient.subscribe('/topic/messages', function(message) {\r\n                onMessageReceived(JSON.parse(message.body));\r\n            });\r\n        \r\n            this.stompClient.subscribe('/topic/online-users', function(users) {\r\n                if (onUsersUpdated) {\r\n                    onUsersUpdated(JSON.parse(users.body));\r\n                }\r\n            });\r\n        \r\n            this.stompClient.subscribe('/topic/typing', function(typingStatus) {\r\n                if (this.typingCallback) {\r\n                    const { username } = JSON.parse(typingStatus.body);\r\n                    this.typingCallback(username);\r\n                }\r\n            });\r\n        \r\n        }, function(error) {\r\n            console.error(\"STOMP connection error: \", error);\r\n            \r\n        });\r\n\r\n        // Set automatic reconnection delay to 5 seconds in case of disconnection\r\n        this.stompClient.reconnectDelay = 5000;\r\n\r\n        this.stompClient.debug = function (str) {\r\n            console.log(str);  // This will log WebSocket connection events\r\n        };\r\n\r\n        // Handle STOMP errors reported by the message broker\r\n        this.stompClient.onStompError = (frame) => {\r\n            console.error('Broker reported error: ' + frame.headers['message']);\r\n            console.error('Additional details: ' + frame.body);\r\n        };\r\n    }\r\n\r\n    // Set up actions to be taken once the connection is successful\r\n    _setupSubscriptions(onMessageReceived, onUsersUpdated) {\r\n        // Subscribe to messages topic to receive chat messages\r\n        this.stompClient.subscribe('/topic/messages', (message) => {\r\n            onMessageReceived(JSON.parse(message.body));  // Invoke the provided callback with the parsed message\r\n        });\r\n\r\n        // Subscribe to the online-users topic to get updates on online users\r\n        this.stompClient.subscribe('/topic/online-users', (users) => {\r\n            if (onUsersUpdated) {\r\n                onUsersUpdated(JSON.parse(users.body));  // Invoke the provided callback with the updated user list\r\n            }\r\n        });\r\n\r\n        // Subscribe to typing topic to receive typing notifications\r\n        this.stompClient.subscribe('/topic/typing', (typingStatus) => {\r\n            if (this.typingCallback) {\r\n                const { username } = JSON.parse(typingStatus.body); // Parse typing status\r\n                this.typingCallback(username);  // Invoke typing callback with username\r\n            }\r\n        });\r\n    }\r\n\r\n    // Set up the callback function for typing notifications\r\n    onTyping(callback) {\r\n        this.typingCallback = callback; // Assign the provided callback to typingCallback\r\n    }\r\n\r\n    // Send typing status to the server for a specific group\r\n    sendTypingStatus(username, group) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/typing',\r\n                body: JSON.stringify({ username, group })\r\n            });\r\n        }\r\n    }\r\n\r\n    // Send a chat message to the server\r\n    sendMessage(message) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/chat',\r\n                body: JSON.stringify(message)\r\n            });\r\n        }\r\n    }\r\n\r\n    // Notify server of user's presence (to mark as online)\r\n    sendUserPresence(username) {\r\n        if (this.stompClient && this.stompClient.connected) {\r\n            this.stompClient.publish({\r\n                destination: '/app/online',\r\n                body: JSON.stringify({ username })\r\n            });\r\n        }\r\n    }\r\n\r\n    // Disconnect the WebSocket client\r\n    disconnect() {\r\n        if (this.stompClient) {\r\n            this.stompClient.deactivate(); // Properly close the connection\r\n            this.isConnected = false;  // Reset connection state\r\n        }\r\n    }\r\n}\r\n\r\n// Export a singleton instance of WebSocketService to be used across the app\r\nconst webSocketService = new WebSocketService();\r\nexport default webSocketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}